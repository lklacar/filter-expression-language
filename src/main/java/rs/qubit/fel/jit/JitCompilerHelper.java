package rs.qubit.fel.jit;

import rs.qubit.fel.evaluator.value.*;
import rs.qubit.fel.exception.FilterException;
import rs.qubit.fel.visitor.VisitorContext;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Helper class providing utility methods for JIT-compiled code.
 * These methods are called from generated bytecode.
 */
public class JitCompilerHelper {

    private static final Map<Integer, Object> CONSTANTS = new ConcurrentHashMap<>();

    /**
     * Register a constant value at a specific index.
     */
    public static void registerConstant(int index, Object value) {
        CONSTANTS.put(index, value);
    }

    /**
     * Retrieve a DateTime constant by index.
     */
    public static LocalDateTime getDateTime(int index) {
        return (LocalDateTime) CONSTANTS.get(index);
    }

    /**
     * Parse a Java object into a Value instance.
     * This mirrors the logic in FilterEvaluator.parseValue().
     */
    public static Value parseValue(Object value, VisitorContext evaluationContext) {
        return switch (value) {
            case Byte b -> new LongValue(Long.valueOf(b));
            case Short s -> new LongValue(Long.valueOf(s));
            case Integer d -> new LongValue(Long.valueOf(d));
            case Long l -> new LongValue(l);
            case Float f -> new DoubleValue(f.doubleValue());
            case Double d -> new DoubleValue(d);
            case Character c -> new StringValue(String.valueOf(c));
            case String s -> new StringValue(s);
            case Boolean b -> new BooleanValue(b);
            case Enum<?> e -> new StringValue(e.name());
            case LocalDateTime d -> new DateTimeValue(d);
            case LocalDate d -> new DateTimeValue(d.atStartOfDay());
            case Instant i -> new DateTimeValue(i.atZone(ZoneId.systemDefault()).toLocalDateTime());
            case null -> new NullValue();
            case Object o -> {
                var parser = evaluationContext.getMapper(value.getClass());
                yield Optional.ofNullable(parser)
                        .map(p -> p.apply(value))
                        .orElseGet(() -> {
                            var isJavaObject = value.getClass().getName().startsWith("java");
                            if (isJavaObject) {
                                throw new FilterException("Cannot convert java object %s to a filter value"
                                        .formatted(value.getClass().getName()));
                            }

                            return new ObjectValue(o);
                        });
            }
        };
    }

    /**
     * Clear all registered constants. Useful for testing.
     */
    public static void clearConstants() {
        CONSTANTS.clear();
    }
}
