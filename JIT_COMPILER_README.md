# JIT Compiler for Filter Expression Language

## Overview

This project now includes a **Just-In-Time (JIT) compiler** that generates optimized JVM bytecode for filter expressions at runtime. The JIT compiler provides significant performance improvements over the interpreted evaluation approach, making it ideal for hot-path filtering operations.

## Performance

Based on benchmarks, the JIT compiler provides approximately **3-4x speedup** over interpreted evaluation for typical filter expressions.

Example benchmark results:
- Interpreted: 129 ms for 100,000 iterations
- JIT Compiled: 37 ms for 100,000 iterations
- **Speedup: 3.45x**

## Architecture

The JIT compilation system consists of several key components:

### Core Components

1. **`JitCompiler`** (`rs.qubit.fel.jit.JitCompiler`)
   - Implements the `ExpressionVisitor` interface
   - Traverses the expression AST and generates JVM bytecode using ASM
   - Creates a class that implements `Predicate<Object>` with compiled filter logic

2. **`JitCompilerContext`** (`rs.qubit.fel.jit.JitCompilerContext`)
   - Holds compilation state during bytecode generation
   - Manages constant storage for complex values like LocalDateTime

3. **`JitCompilerHelper`** (`rs.qubit.fel.jit.JitCompilerHelper`)
   - Provides static helper methods called from generated bytecode
   - Handles value type conversion (Java objects → FEL Value types)
   - Manages constant value storage and retrieval

### Technology Stack

- **ASM 9.7**: Powerful Java bytecode manipulation library
- **ASM Commons**: High-level bytecode generation utilities
- Generates Java 21 compatible bytecode

## Usage

### Basic Usage

Replace `Fel.filter()` with `Fel.filterJit()`:

```java
// Interpreted evaluation
var interpretedFilter = Fel.filter("age >= 30 && city = 'New York'");

// JIT compiled evaluation
var jitFilter = Fel.filterJit("age >= 30 && city = 'New York'");

// Use like any predicate
var results = users.stream().filter(jitFilter).toList();
```

### With Custom Context

```java
var context = new DefaultEvaluationContext();
var jitFilter = Fel.filterJit("age >= 30 && city = 'New York'", context);
```

### From AST

```java
var parser = new FilterParser();
var ast = parser.parse("age >= 30");
var jitFilter = Fel.fromAstJit(ast);
```

## Supported Features

The JIT compiler supports all filter expression features:

- **Literals**: strings, numbers (long/double), booleans, null, dates
- **Identifiers**: field access
- **Dot expressions**: nested field access (`address.city`)
- **Comparison operators**: `=`, `!=`, `>`, `<`, `>=`, `<=`
- **Logical operators**: `&&`, `||`, `!`
- **Short-circuit evaluation**: Optimized boolean logic
- **Function calls**: All built-in and custom functions
- **Custom mappers**: Type conversion functions

## Implementation Details

### Bytecode Generation

For each expression node type, the JIT compiler generates appropriate JVM bytecode:

1. **Literals** → Direct instantiation of Value objects
2. **Identifiers** → Reflection-based field access via `ReflectionUtil`
3. **Operators** → Inline comparison and logical operations
4. **Functions** → Dynamic dispatch through VisitorContext

### Generated Class Structure

```java
public class CompiledPredicateN implements Predicate<Object> {
    private final VisitorContext context;

    public CompiledPredicateN(VisitorContext context) {
        this.context = context;
    }

    @Override
    public boolean test(Object record) {
        // Generated bytecode for expression evaluation
    }
}
```

### Optimizations

- **Short-circuit evaluation**: AND/OR operators skip unnecessary evaluations
- **Direct method invocations**: Minimal overhead compared to reflection
- **Value type conversions**: Cached and optimized through helpers
- **No interpretation overhead**: Direct bytecode execution

## When to Use JIT Compilation

### Good Use Cases ✅

- High-frequency filtering (millions of records)
- Hot-path filtering in performance-critical code
- Long-running services with stable filter expressions
- Batch processing with repeated filter evaluation

### Consider Interpreted Evaluation ⚠️

- One-time or infrequent filtering
- Dynamic filters that change frequently
- Initial development and debugging
- Simple expressions on small datasets

## Testing

Comprehensive test coverage with 22 JIT-specific tests:

- All expression types (literals, operators, functions)
- Short-circuit evaluation
- Complex nested expressions
- Comparison with interpreted results
- Custom functions and mappers

Run JIT tests:
```bash
mvn test -Dtest=JitCompilerTest
```

Run example with performance comparison:
```bash
mvn test-compile exec:java \
  -Dexec.mainClass="rs.qubit.fel.jit.JitExample" \
  -Dexec.classpathScope=test
```

## API Methods

### `Fel.filterJit(String filter)`
Creates a JIT-compiled predicate from a filter string using default context.

### `Fel.filterJit(String filter, VisitorContext context)`
Creates a JIT-compiled predicate with custom context (functions/mappers).

### `Fel.fromAstJit(ExpressionNode ast)`
Creates a JIT-compiled predicate from an AST using default context.

### `Fel.fromAstJit(ExpressionNode ast, VisitorContext context)`
Creates a JIT-compiled predicate from an AST with custom context.

## Limitations

- Generated classes are not cached (each call creates a new class)
- ClassLoader creates one class per compilation
- Function calls still go through interface dispatch
- Reflection is still used for field access

## Future Enhancements

Potential optimizations:
- **Compilation caching**: Reuse generated classes for identical expressions
- **Inline field access**: Generate direct field access bytecode for known types
- **Method handles**: Replace reflection with MethodHandles for faster field access
- **AOT compilation**: Pre-compile common filters at build time

## Dependencies

```xml
<dependency>
    <groupId>org.ow2.asm</groupId>
    <artifactId>asm</artifactId>
    <version>9.7</version>
</dependency>
<dependency>
    <groupId>org.ow2.asm</groupId>
    <artifactId>asm-commons</artifactId>
    <version>9.7</version>
</dependency>
```

## Example Output

```
=== Performance Comparison ===
Interpreted: 129 ms
JIT Compiled: 37 ms
Speedup: 3.45x
```

## Contributing

The JIT compiler follows the visitor pattern established in the codebase. To add support for new expression types:

1. Add bytecode generation in `JitCompiler.visit()` method
2. Add helper methods to `JitCompilerHelper` if needed
3. Add comprehensive tests in `JitCompilerTest`
4. Verify compatibility with interpreted evaluation

---

**Note**: The JIT compiler maintains 100% compatibility with the interpreted evaluator - all tests that pass with interpreted evaluation also pass with JIT compilation.
